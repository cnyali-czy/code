    这题可以用Dijkstra最短路径来做，但不同于一般的最短路径。
    让每个cremator（本人尚不知道这个单词是什么意思。现在，iciba网站坏了查不了~）作为一个结点，让管道作为边，管道必要时间作为边权。我们的目的就是求一条从0到n的最短路径。
    模仿Dijkstra，得到一个算法：
    （1）将所有结点都标记成灰色且路径长度记为INT_MAX。特别地，将0这个点的路径长度记为0；
    （2）在灰色结点中找出路径长度最小的结点v，将其标记为黑色；
    （3）查看v的边，对于任意的<v, u>，设<v, u>的必要时间为cost<v, u>，若earliest_time(v) + cost<v, u>这个时间u正在放火，那么等到u开始清理的时候再走到u去（不然就立刻走到u去）。把到u之后的时间记为t,则用t去试着更新earliest_time(u)；
    （4）如果n这个点还是灰色，则转入（2）；否则结束过程。
    很容易证明这个算法的正确性。但是我还是要提醒大家，这并不是一般的最短路问题。从某种意义上来说，这里的管道上的权不是固定的（因为从v走到u，加上的时间并不是单纯的cost<v, u>，还要考虑u是否在放火）。而一般的最短路问题，权值总是固定的。不过这道题也有特殊性，即，从0走到v，然后通过<v, u>走到u，若这样的一条路是最早到u的，那么到v的时间也是可以是最早的。从这个角度看，似乎一切普通最短路问题的算法，在这题上都可以正确使用。但要是没有这样的性质，作为一个非经典问题，在用最短路的时候要三思。
    我提供的官方的程序。

    陈明骋
